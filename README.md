Проект-эксперимент в качестве попытки создать игру на Unity в более функциональном стиле. В каком-то смысле является следствием этой статьи:<br/> https://docs.google.com/document/d/1S9UB4-s4ALFJHG7SL766_cXGThlP77eGG_tC1nkpa30/edit?usp=sharing.<br/>
Чтобы использование альтернативы ООП имело смысл были выбраны механики которые проще написать в функциональном стиле.<br/>
Основная логика находится в Assets\Scripts\CardGrid\CardGridGameLogic по факту является одним C# скриптом разделенном на partial(да, звучит жутко), основным является CardGridGame. Далее подробности такой структуризации кода.

Суть игры:<br/>
![CG25](https://user-images.githubusercontent.com/86427892/180674746-9284ea4d-9a58-4a2e-a046-5c87728ac2d5.gif)<br/>
У нас есть поле с врагами за убийство которых даются очки/монеты. При уничтожении карты столбец на поле опускается вниз заменяя недостающие сверху карты новыми. Делать это можно собирая комбинации из карт или предметами из инвентаря. Новые предметы попадают в инвентарь, когда достигают нижней линии поля.
У каждого предмета и противника свои особенности и обстоятельства при которых они активируются.<br/>
К примеру:<br/>
противник наносящий урон соседним клеткам при получении урона,<br/>
противник при убийстве которого в инвентарь выдается новый предмет,<br/>
предмет наносящий урон только близко стоящим противникам,<br/>
предметы перемещающиеся объекты по полю - отталкивающие и меняющие карты местами.<br/>
Манипуляция картами на поле имеет смысл потому что карты могут складываться в полезные для игрока комбинации.

Такой набор механик делает разработку в ООП стиле неприятным занятием. У карты есть много источников и условий при которых срабатывает её способность, а сама способность может влиять на большое количество чужих состояний. Не получится создать класс Card в котором просто менять состояние в зависимости от карты, потому что каждой карте требуется уникальная логика и набор данных необходимых для ее осуществления. Создавать для каждой карты отдельный класс который наследуется от Card тоже плохая идея, так как для всех вариантов взаимодействия с картами количество интерфейсов (внешний зависимостей от событий) которые должен реализовывать Card очень велико, отдельная карта будет реализовывать основной класс лишь частично, что противоречит основным требованиям ООП, к тому же в течении разработки класс Card может не раз изменяться, что сразу сказывается на конкретных реализациях карт, которые от него зависят. Основная логика игры - взаимодействие карт, будет разбросано по десятку файлов. Также кроме кодера такую карту никто не сможет понять и изменить.

Я попробовал структурировать такой проект с очень большими отличиями от стандартного ООП. Основная логика игры представлена по факту в одном скрипте - модуле самой игры, разделенном на несколько файлов. Части на которые я разделил код мне кажеться не идеальным, в процессе разработки игры расположение кода стоит менять. Преимущество структуризации кода в таком стиле в том, что он ставит целью только повышение читаемости - расположение кода не влияет на его функциональность и связанность. В отличие от ООП стиля где разделение кода по отдельным объектам накладывает ограничения по их взаимодействию, здесь разделение исключительно смысловое, что позволяет нам без проблем перемещать код между частями общего скрипта, без дополнительных трудностей переосмысливать принадлежность логики в конкретной механике.

 В папке кода игры Assets\Scripts\CardGrid Отдельно расположены:<br/>
Папка с Monobehaviours , которые являются лишь контейнерами для связи с объектами движка.<br/>
ScriptableObject(SO) которые служат для настройки уровней и карт.<br/>
В файле States содержаться состояния карт и самого игрока. Они также используются в системы сохранений ES3.<br/>
В файле Maps содержатся карты воздействия на поле. Чтобы каждый раз не прописывать логикой на какие клетки должны воздействовать карты применяется выбранная мапа.

В коде реализована только механика нанесения урона мапами только от предметов и раненых/убитых врагов, что не полностью раскрывает идею проекта и его комплексность, но служит примером кода исходя из которого можно сделать выводы о читаемости такого кода.
